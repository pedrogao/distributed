# lock service

在本实验中，您将构建一个锁定服务，即使服务器出现单个“故障停止”故障，该服务仍可继续运行。
客户端将通过 RPC 与您的锁定服务通信。客户端可以使用两个 RPC 请求：Lock(lockname) 和 Unlock(lockname)。
锁服务维护关于一组开放式命名锁的状态。如果 Lock(lockname) 请求到达服务并且指定的锁没有被持有，或者之前从未使用过，
锁服务应该记住锁被持有，并向客户端返回一个成功的回复。如果锁被持有，服务应该向客户端返回一个不成功的回复。
如果客户端发送 Unlock(lockname)，服务应该将指定的锁标记为未持有。
如果锁被持有，服务应该向客户端返回一个成功的回复；否则回复不成功。

您的锁定服务将在两台服务器上复制，一台主服务器和一台备份服务器。
如果没有失败，客户端将向主节点发送锁定和解锁请求，主节点会将它们转发给备份。
关键是备份保持与主节点相同的状态（即，主节点和备份状态应该就每个锁是持有还是释放达成一致）。

您的系统需要容忍的唯一故障是单个故障停止服务器故障。故障停止失败意味着服务器停止。
本实验中没有其他类型的故障（例如，客户端不故障，网络不故障，所有网络消息都传递到未崩溃的服务器，
服务器仅因停止而不是因计算错误而发生故障）。
在本实验室中，服务器永远不会被修复——一旦主服务器或备份服务器发生故障，它将一直处于故障状态。

如果客户端无法从主服务器获得响应，它应该联系备份服务器。
如果主服务器在转发客户端请求时无法从备份服务器获得响应，则主服务器应停止将客户端请求转发到备份服务器。

本实验中的故障模型（无网络故障，无服务器修复）非常有限，以至于您的锁定服务在实践中不会有太大用处；
随后的实验室将能够容忍更广泛的故障。


## 参考资料

- [How to generate a random string of a fixed length in Go?](https://stackoverflow.com/questions/22892120/how-to-generate-a-random-string-of-a-fixed-length-in-go/22892986#22892986)